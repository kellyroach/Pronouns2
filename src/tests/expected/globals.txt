\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}
\symbol{35}
\symbol{35}~~~~globals.py
\symbol{35}
\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}\symbol{35}

"""Global~constants,~enums,~and~data~structures~for~syntax~tree~processing."""

import~sys
from~enum~import~Enum,~IntEnum
from~typing~import~Optional

class~FeatureIndex(IntEnum):
~~~~"""Feature~indices~for~linguistic~properties."""
~~~~PNF~=~0
~~~~"""Pronoun~Feature"""
~~~~FPF~=~1
~~~~"""First~Person~Feature"""
~~~~SPF~=~2
~~~~"""Second~Person~Feature"""
~~~~TPF~=~3
~~~~"""Third~Person~Feature"""
~~~~PLF~=~4
~~~~"""Plural~Feature"""
~~~~GNF~=~5
~~~~"""Gender~Feature"""
~~~~ANF~=~6
~~~~"""Animate~Feature"""
~~~~RPF~=~7
~~~~"""Reflexive~Feature"""
~~~~GEN~=~8
~~~~"""Genitive~Feature"""
~~~~def~\symbol{95}\symbol{95}repr\symbol{95}\symbol{95}(self):
~~~~~~~~\symbol{35}~Dynamically~retrieve~the~class~name
~~~~~~~~return~f"\symbol{123}self.\symbol{95}\symbol{95}class\symbol{95}\symbol{95}.\symbol{95}\symbol{95}name\symbol{95}\symbol{95}\symbol{125}.\symbol{123}self.name\symbol{125}"
~~~~def~\symbol{95}\symbol{95}str\symbol{95}\symbol{95}(self):
~~~~~~~~\symbol{35}~Dynamically~retrieve~the~class~name
~~~~~~~~return~f"\symbol{123}self.\symbol{95}\symbol{95}class\symbol{95}\symbol{95}.\symbol{95}\symbol{95}name\symbol{95}\symbol{95}\symbol{125}.\symbol{123}self.name\symbol{125}"

N\symbol{95}FEATURES~=~len(FeatureIndex)
"""Number~of~Features"""

HIDE\symbol{95}GEN~=~False
"""GEN~introduced~by~Chapter~12~in~M.S.~thesis"""

class~NodeId(Enum):
~~~~"""Identifies~the~type~of~node~in~the~syntax~tree."""
~~~~C\symbol{95}NODE~=~0
~~~~"""Type~of~Node~which~represents~a~C-node."""
~~~~S\symbol{95}NODE~=~1
~~~~"""Type~of~Node~which~represents~an~S-node."""
~~~~N\symbol{95}NODE~=~2
~~~~"""Type~of~Node~which~represents~an~N-node."""
~~~~E\symbol{95}NODE~=~3
~~~~"""Type~of~Node~which~represents~an~E-node."""
~~~~def~\symbol{95}\symbol{95}repr\symbol{95}\symbol{95}(self):
~~~~~~~~\symbol{35}~Dynamically~retrieve~the~class~name
~~~~~~~~return~f"\symbol{123}self.\symbol{95}\symbol{95}class\symbol{95}\symbol{95}.\symbol{95}\symbol{95}name\symbol{95}\symbol{95}\symbol{125}.\symbol{123}self.name\symbol{125}"
~~~~def~\symbol{95}\symbol{95}str\symbol{95}\symbol{95}(self):
~~~~~~~~\symbol{35}~Dynamically~retrieve~the~class~name
~~~~~~~~return~f"\symbol{123}self.\symbol{95}\symbol{95}class\symbol{95}\symbol{95}.\symbol{95}\symbol{95}name\symbol{95}\symbol{95}\symbol{125}.\symbol{123}self.name\symbol{125}"

class~Feature(Enum):
~~~~"""Represents~feature~values~for~linguistic~properties."""
~~~~PLUS~=~0
~~~~"""Node~or~word~has~this~feature."""
~~~~MINUS~=~1
~~~~"""Node~or~word~doesn't~have~this~feature."""
~~~~QUESTION~=~2
~~~~"""Node~or~word~might~or~might~not~have~this~feature."""
~~~~def~\symbol{95}\symbol{95}repr\symbol{95}\symbol{95}(self):
~~~~~~~~\symbol{35}~Dynamically~retrieve~the~class~name
~~~~~~~~return~f"\symbol{123}self.\symbol{95}\symbol{95}class\symbol{95}\symbol{95}.\symbol{95}\symbol{95}name\symbol{95}\symbol{95}\symbol{125}.\symbol{123}self.name\symbol{125}"
~~~~def~\symbol{95}\symbol{95}str\symbol{95}\symbol{95}(self):
~~~~~~~~\symbol{35}~Dynamically~retrieve~the~class~name
~~~~~~~~return~f"\symbol{123}self.\symbol{95}\symbol{95}class\symbol{95}\symbol{95}.\symbol{95}\symbol{95}name\symbol{95}\symbol{95}\symbol{125}.\symbol{123}self.name\symbol{125}"

\symbol{35}~Type~aliases
Features~=~list[Feature]
"""Type~alias~for~a~list~of~Feature~enums~representing~linguistic~properties."""

class~Node:
~~~~"""Base~node~class~for~syntax~tree~representation.
~~~~
~~~~Contains~fields~for~tree~structure~(links),~features,~and~node-specific~properties.
~~~~Different~node~types~(C,~S,~N,~E)~use~different~subsets~of~these~fields.
~~~~"""
~~~~\symbol{35}~Global~reference~to~the~current~syntax~tree
~~~~\symbol{95}tree:~Optional['Node']~=~None
~~~~def~\symbol{95}\symbol{95}init\symbol{95}\symbol{95}(self):
~~~~~~~~"""Initializes~a~new~Node~with~all~possible~fields~set~to~default~values."""
~~~~~~~~self.number:~int~=~0
~~~~~~~~self.up\symbol{95}link:~Optional['Node']~=~None
~~~~~~~~self.down\symbol{95}link:~Optional['Node']~=~None
~~~~~~~~self.left\symbol{95}link:~Optional['Node']~=~None
~~~~~~~~self.right\symbol{95}link:~Optional['Node']~=~None
~~~~~~~~self.thread\symbol{95}link:~Optional['Node']~=~None
~~~~~~~~self.np\symbol{95}link:~Optional['Node']~=~None
~~~~~~~~self.chain\symbol{95}link:~Optional['Node']~=~None
~~~~~~~~self.col\symbol{95}link:~Optional['Node']~=~None
~~~~~~~~self.ftr:~Features~=~[Feature.QUESTION]~*~N\symbol{95}FEATURES
~~~~~~~~self.id:~NodeId~=~NodeId.C\symbol{95}NODE
~~~~~~~~self.lit:~str~=~""
~~~~~~~~self.end\symbol{95}col\symbol{95}link:~Optional['Node']~=~None
~~~~~~~~self.pred\symbol{95}link:~Optional['Node']~=~None
~~~~~~~~self.succ\symbol{95}link:~Optional['Node']~=~None
~~~~~~~~self.sub:~str~=~'~'
~~~~@property
~~~~def~ftr\symbol{95}str(self)~->~str:
~~~~~~~~result~=~['?'~if~f~==~Feature.QUESTION~else
~~~~~~~~~~~~~~~~~~'+'~if~f~==~Feature.PLUS~else
~~~~~~~~~~~~~~~~~~'-'~for~f~in~self.ftr]
~~~~~~~~if~HIDE\symbol{95}GEN:
~~~~~~~~~~~~result~=~result[:-1]
~~~~~~~~return~f"\symbol{123}''.join(result)\symbol{125}"
~~~~@classmethod
~~~~def~tree(cls)~->~Optional['Node']:
~~~~~~~~"""Gets~the~global~syntax~tree."""
~~~~~~~~return~cls.\symbol{95}tree
~~~~@classmethod
~~~~def~set\symbol{95}tree(cls,~new\symbol{95}tree:~'Node')~->~None:
~~~~~~~~"""Sets~the~global~syntax~tree."""
~~~~~~~~cls.\symbol{95}tree~=~new\symbol{95}tree

class~FileType(Enum):
~~~~"""Controls~the~output~format~and~detail~level."""
~~~~TXT~=~0
~~~~"""Plain~text~output"""
~~~~TEX~=~1
~~~~"""LaTeX~formatted~output"""
~~~~def~\symbol{95}\symbol{95}repr\symbol{95}\symbol{95}(self):
~~~~~~~~\symbol{35}~Dynamically~retrieve~the~class~name
~~~~~~~~return~f"\symbol{123}self.\symbol{95}\symbol{95}class\symbol{95}\symbol{95}.\symbol{95}\symbol{95}name\symbol{95}\symbol{95}\symbol{125}.\symbol{123}self.name\symbol{125}"
~~~~def~\symbol{95}\symbol{95}str\symbol{95}\symbol{95}(self):
~~~~~~~~\symbol{35}~Dynamically~retrieve~the~class~name
~~~~~~~~return~f"\symbol{123}self.\symbol{95}\symbol{95}class\symbol{95}\symbol{95}.\symbol{95}\symbol{95}name\symbol{95}\symbol{95}\symbol{125}.\symbol{123}self.name\symbol{125}"
~~~~@property
~~~~def~file\symbol{95}ext(self):
~~~~~~~~"""Returns~the~file~extension~associated~with~the~file~type."""
~~~~~~~~type\symbol{95}to\symbol{95}ext~=~\symbol{123}
~~~~~~~~~~~~FileType.TXT:~".txt",
~~~~~~~~~~~~FileType.TEX:~".tex",
~~~~~~~~\symbol{125}
~~~~~~~~return~type\symbol{95}to\symbol{95}ext[self]
~~~~@staticmethod
~~~~def~from\symbol{95}ext(ext:~str)~->~"FileType":
~~~~~~~~"""Maps~a~file~extension~string~to~its~corresponding~FileType."""
~~~~~~~~ext\symbol{95}to\symbol{95}type~=~\symbol{123}
~~~~~~~~~~~~".txt":~FileType.TXT,
~~~~~~~~~~~~".tex":~FileType.TEX,
~~~~~~~~\symbol{125}
~~~~~~~~if~ext~not~in~ext\symbol{95}to\symbol{95}type:
~~~~~~~~~~~~raise~ValueError(f"Unknown~file~extension:~\symbol{123}ext\symbol{125}")
~~~~~~~~return~ext\symbol{95}to\symbol{95}type[ext]

class~Manager:
~~~~"""
~~~~A~singleton~class~for~managing~output~streams~and~file~types.

~~~~The~Manager~class~centralizes~state~management~for~output~streams~
~~~~and~file~types~used~in~the~application.~It~maintains~a~stack~of~
~~~~states~to~allow~nested~context~management~with~automatic~state~
~~~~restoration.~The~class~supports~Python~"with~statement"~to~manage~
~~~~the~active~state~context~and~provides~class-level~methods~and~
~~~~properties~for~accessing~and~updating~the~current~state.
~~~~"""
~~~~manager:~Optional['Manager']~=~None
~~~~"""The~singleton~instance~of~the~class."""
~~~~def~\symbol{95}\symbol{95}init\symbol{95}\symbol{95}(self):
~~~~~~~~self.state~=~\symbol{123}'stream':~sys.stdout,
~~~~~~~~~~~~~~~~~~~~~~'file\symbol{95}type':~FileType.TXT,
~~~~~~~~~~~~~~~~~~~~~~'info':~False,
~~~~~~~~~~~~~~~~~~~~~~'features\symbol{95}table':~True,
~~~~~~~~~~~~~~~~~~~~~~'abstract\symbol{95}diagram':~True,
~~~~~~~~~~~~~~~~~~~~~~'nodes\symbol{95}after\symbol{95}chaining':~True,
~~~~~~~~~~~~~~~~~~~~~~'nodes\symbol{95}table':~True,
~~~~~~~~~~~~~~~~~~~~~~'chaining\symbol{95}diagram':~True,
~~~~~~~~~~~~~~~~~~~~~~'chaining\symbol{95}rho':~0.5,
~~~~~~~~~~~~~~~~~~~~~~'chaining\symbol{95}table':~True,
~~~~~~~~~~~~~~~~~~~~~~'interpretations\symbol{95}table':~True,
~~~~~~~~~~~~~~~~~~~~~~'summary\symbol{95}table':~True,
~~~~~~~~~~~~~~~~~~~~~~'lexicon\symbol{95}table':~True,
~~~~~~~~~~~~~~~~~~~~~~'debug':~False,
~~~~~~~~~~~~~~~~~~~~~~'nodes\symbol{95}after\symbol{95}parse':~True,
~~~~~~~~~~~~~~~~~~~~~~'init\symbol{95}table':~True,
~~~~~~~~~~~~~~~~~~~~~~'new\symbol{95}chain':~True,
~~~~~~~~~~~~~~~~~~~~~~'trace':~False\symbol{125}
~~~~~~~~self.state\symbol{95}stack~=~[]
~~~~def~\symbol{95}\symbol{95}enter\symbol{95}\symbol{95}(self):
~~~~~~~~\symbol{35}~Push~current~state~onto~stack
~~~~~~~~self.state\symbol{95}stack.append(self.state.copy())
~~~~~~~~return~self
~~~~def~\symbol{95}\symbol{95}exit\symbol{95}\symbol{95}(self,~exc\symbol{95}type,~exc\symbol{95}val,~exc\symbol{95}tb):
~~~~~~~~\symbol{35}~Restore~previous~state,~even~if~exception~occurred
~~~~~~~~if~self.state\symbol{95}stack:
~~~~~~~~~~~~self.state~=~self.state\symbol{95}stack.pop()
~~~~~~~~return~False~~\symbol{35}~Let~exceptions~propagate
~~~~@classmethod
~~~~@property
~~~~def~state(cls):
~~~~~~~~"""Class~property~to~return~the~state~of~the~singleton~instance."""
~~~~~~~~return~cls.manager.state
~~~~@classmethod
~~~~def~set\symbol{95}state(cls,~**kwargs):
~~~~~~~~"""Class~method~to~update~the~state~of~the~singleton~instance."""
~~~~~~~~if~cls.manager~is~not~None:
~~~~~~~~~~~~\symbol{35}~Filter~out~key-value~pairs~where~value~is~None
~~~~~~~~~~~~filtered\symbol{95}kwargs~=~\symbol{123}key:~value~for~key,~value~in~kwargs.items()~if~value~is~not~None\symbol{125}
~~~~~~~~~~~~\symbol{35}~Update~the~state~with~the~filtered~dictionary
~~~~~~~~~~~~cls.manager.state.update(filtered\symbol{95}kwargs)
~~~~@classmethod
~~~~def~write(cls,~message:~str):
~~~~~~~~"""Writes~a~message~to~the~currently~configured~output~stream."""
~~~~~~~~cls.stream.write(message)
~~~~@classmethod
~~~~@property
~~~~def~stream(cls):
~~~~~~~~"""Class~property~for~'stream'."""
~~~~~~~~return~cls.manager.state['stream']
~~~~@classmethod
~~~~@property
~~~~def~file\symbol{95}type(cls):
~~~~~~~~"""Class~property~for~'file\symbol{95}type'."""
~~~~~~~~return~cls.manager.state['file\symbol{95}type']
~~~~@classmethod
~~~~@property
~~~~def~info(cls):
~~~~~~~~"""Class~property~for~'info'."""
~~~~~~~~return~cls.manager.state['info']
~~~~@classmethod
~~~~@property
~~~~def~features\symbol{95}table(cls):
~~~~~~~~"""Class~property~for~'features\symbol{95}table'."""
~~~~~~~~return~cls.manager.state['features\symbol{95}table']
~~~~@classmethod
~~~~@property
~~~~def~abstract\symbol{95}diagram(cls):
~~~~~~~~"""Class~property~for~'abstract\symbol{95}diagram'."""
~~~~~~~~return~cls.manager.state['abstract\symbol{95}diagram']
~~~~@classmethod
~~~~@property
~~~~def~nodes\symbol{95}table(cls):
~~~~~~~~"""Class~property~for~'nodes\symbol{95}table'."""
~~~~~~~~return~cls.manager.state['nodes\symbol{95}table']
~~~~@classmethod
~~~~@property
~~~~def~chaining\symbol{95}diagram(cls):
~~~~~~~~"""Class~property~for~'chaining\symbol{95}diagram'."""
~~~~~~~~return~cls.manager.state['chaining\symbol{95}diagram']
~~~~@classmethod
~~~~@property
~~~~def~chaining\symbol{95}rho(cls):
~~~~~~~~"""Class~property~for~'chaining\symbol{95}rho'."""
~~~~~~~~return~cls.manager.state['chaining\symbol{95}rho']
~~~~@classmethod
~~~~@property
~~~~def~chaining\symbol{95}table(cls):
~~~~~~~~"""Class~property~for~'chaining\symbol{95}table'."""
~~~~~~~~return~cls.manager.state['chaining\symbol{95}table']
~~~~@classmethod
~~~~@property
~~~~def~interpretations\symbol{95}table(cls):
~~~~~~~~"""Class~property~for~'interpretations\symbol{95}table'."""
~~~~~~~~return~cls.manager.state['interpretations\symbol{95}table']
~~~~@classmethod
~~~~@property
~~~~def~summary\symbol{95}table(cls):
~~~~~~~~"""Class~property~for~'summary\symbol{95}table'."""
~~~~~~~~return~cls.manager.state['summary\symbol{95}table']
~~~~@classmethod
~~~~@property
~~~~def~lexicon\symbol{95}table(cls):
~~~~~~~~"""Class~property~for~'lexicon\symbol{95}table'."""
~~~~~~~~return~cls.manager.state['lexicon\symbol{95}table']
~~~~@classmethod
~~~~@property
~~~~def~debug(cls):
~~~~~~~~"""Class~property~for~'debug'."""
~~~~~~~~return~cls.manager.state['debug']
~~~~@classmethod
~~~~@property
~~~~def~nodes\symbol{95}after\symbol{95}parse(cls):
~~~~~~~~"""Class~property~for~'nodes\symbol{95}after\symbol{95}parse'."""
~~~~~~~~return~cls.manager.state['nodes\symbol{95}after\symbol{95}parse']
~~~~@classmethod
~~~~@property
~~~~def~nodes\symbol{95}after\symbol{95}chaining(cls):
~~~~~~~~"""Class~property~for~'nodes\symbol{95}after\symbol{95}chaining'."""
~~~~~~~~return~cls.manager.state['nodes\symbol{95}after\symbol{95}chaining']
~~~~@classmethod
~~~~@property
~~~~def~init\symbol{95}table(cls):
~~~~~~~~"""Class~property~for~'init\symbol{95}table'."""
~~~~~~~~return~cls.manager.state['init\symbol{95}table']
~~~~@classmethod
~~~~@property
~~~~def~new\symbol{95}chain(cls):
~~~~~~~~"""Class~property~for~'new\symbol{95}chain'."""
~~~~~~~~return~cls.manager.state['new\symbol{95}chain']
~~~~@classmethod
~~~~@property
~~~~def~trace(cls):
~~~~~~~~"""Class~property~for~'trace'."""
~~~~~~~~return~cls.manager.state['trace']
~~~~@classmethod
~~~~@property
~~~~def~minimum(cls):
~~~~~~~~"""Class~property~for~'minimum'."""
~~~~~~~~return~(not~(cls.manager.state['info']
~~~~~~~~~~~~~~~~~~~~~or~cls.manager.state['debug']
~~~~~~~~~~~~~~~~~~~~~or~cls.manager.state['trace']))

\symbol{35}~Initialize~the~singleton~inside~the~class~definition
Manager.manager~=~Manager()

class~Summary:
~~~~"""Static~class~to~track~various~info~counts~in~the~project.
~~~~
~~~~Contains~five~integer~counters~that~can~be~accessed~and~modified~by~any~module:
~~~~-~meaningless:~Counter~for~meaningless~items
~~~~-~meaningful:~Counter~for~meaningful~items~
~~~~-~ambiguous:~Counter~for~ambiguous~items
~~~~-~correct:~Counter~for~correct~items
~~~~-~total:~Total~number~of~items
~~~~"""
~~~~meaningless:~int~=~0
~~~~meaningful:~int~=~0
~~~~ambiguous:~int~=~0
~~~~correct:~int~=~0
~~~~total:~int~=~0
~~~~@classmethod
~~~~def~reset(cls)~->~None:
~~~~~~~~"""Resets~all~counters~to~zero."""
~~~~~~~~cls.meaningless~=~0
~~~~~~~~cls.meaningful~=~0
~~~~~~~~cls.ambiguous~=~0
~~~~~~~~cls.correct~=~0
~~~~~~~~cls.total~=~0
